fn main() {
	trace(fibonacci1(35));
	trace(fibonacci2(35));
	trace(fibonacci3(35));
	trace(fibonacci4(35));
	trace(fibonacci5(35));
	trace(fibonacci6(35));
	trace(fibonacci7(35));
	trace(fibonacci8(35));
	trace(fibonacci9(35));
	trace(fibonacci10(35));
	trace(fibonacci11(35));
	trace(fibonacci12(35));
	trace(fibonacci13(35));
	trace(fibonacci14(35));
	trace(fibonacci15(35));
	trace(fibonacci16(35));
	trace(fibonacci17(35));
	trace(fibonacci18(35));
	trace(fibonacci19(35));
	trace(fibonacci20(35));
	trace(fibonacci21(35));
	trace(fibonacci22(35));
	trace(fibonacci23(35));
	trace(fibonacci24(35));
	trace(fibonacci25(35));
	trace(fibonacci26(35));
	trace(fibonacci27(35));
	trace(fibonacci28(35));
	trace(fibonacci29(35));
	trace(fibonacci30(35));
	trace(fibonacci31(35));
	trace(fibonacci32(35));
	trace(fibonacci33(35));
	trace(fibonacci34(35));
	trace(fibonacci35(35));
	trace(fibonacci36(35));
	trace(fibonacci37(35));
	trace(fibonacci38(35));
	trace(fibonacci39(35));
	trace(fibonacci40(35));
	trace(fibonacci41(35));
	trace(fibonacci42(35));
	trace(fibonacci43(35));
	trace(fibonacci44(35));
	trace(fibonacci45(35));
	trace(fibonacci46(35));
	trace(fibonacci47(35));
	trace(fibonacci48(35));
	trace(fibonacci49(35));
	trace(fibonacci50(35));
	trace(fibonacci51(35));
	trace(fibonacci52(35));
	trace(fibonacci53(35));
	trace(fibonacci54(35));
	trace(fibonacci55(35));
	trace(fibonacci56(35));
	trace(fibonacci57(35));
	trace(fibonacci58(35));
	trace(fibonacci59(35));
	trace(fibonacci60(35));
	trace(fibonacci61(35));
	trace(fibonacci62(35));
	trace(fibonacci63(35));
	trace(fibonacci64(35));
	trace(fibonacci65(35));
	trace(fibonacci66(35));
	trace(fibonacci67(35));
	trace(fibonacci68(35));
	trace(fibonacci69(35));
	trace(fibonacci70(35));
	trace(fibonacci71(35));
	trace(fibonacci72(35));
	trace(fibonacci73(35));
	trace(fibonacci74(35));
	trace(fibonacci75(35));
	trace(fibonacci76(35));
	trace(fibonacci77(35));
	trace(fibonacci78(35));
	trace(fibonacci79(35));
	trace(fibonacci80(35));
	trace(fibonacci81(35));
	trace(fibonacci82(35));
	trace(fibonacci83(35));
	trace(fibonacci84(35));
	trace(fibonacci85(35));
	trace(fibonacci86(35));
	trace(fibonacci87(35));
	trace(fibonacci88(35));
	trace(fibonacci89(35));
	trace(fibonacci90(35));
	trace(fibonacci91(35));
	trace(fibonacci92(35));
	trace(fibonacci93(35));
	trace(fibonacci94(35));
	trace(fibonacci95(35));
	trace(fibonacci96(35));
	trace(fibonacci97(35));
	trace(fibonacci98(35));
	trace(fibonacci99(35));
	trace(fibonacci100(35));
	trace(fibonacci101(35));
	trace(fibonacci102(35));
	trace(fibonacci103(35));
	trace(fibonacci104(35));
	trace(fibonacci105(35));
	trace(fibonacci106(35));
	trace(fibonacci107(35));
	trace(fibonacci108(35));
	trace(fibonacci109(35));
	trace(fibonacci110(35));
	trace(fibonacci111(35));
	trace(fibonacci112(35));
	trace(fibonacci113(35));
	trace(fibonacci114(35));
	trace(fibonacci115(35));
	trace(fibonacci116(35));
	trace(fibonacci117(35));
	trace(fibonacci118(35));
	trace(fibonacci119(35));
	trace(fibonacci120(35));
	trace(fibonacci121(35));
	trace(fibonacci122(35));
	trace(fibonacci123(35));
	trace(fibonacci124(35));
	trace(fibonacci125(35));
	trace(fibonacci126(35));
	trace(fibonacci127(35));
	trace(fibonacci128(35));
	trace(fibonacci129(35));
	trace(fibonacci130(35));
	trace(fibonacci131(35));
	trace(fibonacci132(35));
	trace(fibonacci133(35));
	trace(fibonacci134(35));
	trace(fibonacci135(35));
	trace(fibonacci136(35));
	trace(fibonacci137(35));
	trace(fibonacci138(35));
	trace(fibonacci139(35));
	trace(fibonacci140(35));
	trace(fibonacci141(35));
	trace(fibonacci142(35));
	trace(fibonacci143(35));
	trace(fibonacci144(35));
	trace(fibonacci145(35));
	trace(fibonacci146(35));
	trace(fibonacci147(35));
	trace(fibonacci148(35));
	trace(fibonacci149(35));
	trace(fibonacci150(35));
	trace(fibonacci151(35));
	trace(fibonacci152(35));
	trace(fibonacci153(35));
	trace(fibonacci154(35));
	trace(fibonacci155(35));
	trace(fibonacci156(35));
	trace(fibonacci157(35));
	trace(fibonacci158(35));
	trace(fibonacci159(35));
	trace(fibonacci160(35));
	trace(fibonacci161(35));
	trace(fibonacci162(35));
	trace(fibonacci163(35));
	trace(fibonacci164(35));
	trace(fibonacci165(35));
	trace(fibonacci166(35));
	trace(fibonacci167(35));
	trace(fibonacci168(35));
	trace(fibonacci169(35));
	trace(fibonacci170(35));
	trace(fibonacci171(35));
	trace(fibonacci172(35));
	trace(fibonacci173(35));
	trace(fibonacci174(35));
	trace(fibonacci175(35));
	trace(fibonacci176(35));
	trace(fibonacci177(35));
	trace(fibonacci178(35));
	trace(fibonacci179(35));
	trace(fibonacci180(35));
	trace(fibonacci181(35));
	trace(fibonacci182(35));
	trace(fibonacci183(35));
	trace(fibonacci184(35));
	trace(fibonacci185(35));
	trace(fibonacci186(35));
	trace(fibonacci187(35));
	trace(fibonacci188(35));
	trace(fibonacci189(35));
	trace(fibonacci190(35));
	trace(fibonacci191(35));
	trace(fibonacci192(35));
	trace(fibonacci193(35));
	trace(fibonacci194(35));
	trace(fibonacci195(35));
	trace(fibonacci196(35));
	trace(fibonacci197(35));
	trace(fibonacci198(35));
	trace(fibonacci199(35));
	trace(fibonacci200(35));
	trace(fibonacci201(35));
	trace(fibonacci202(35));
	trace(fibonacci203(35));
	trace(fibonacci204(35));
	trace(fibonacci205(35));
	trace(fibonacci206(35));
	trace(fibonacci207(35));
	trace(fibonacci208(35));
	trace(fibonacci209(35));
	trace(fibonacci210(35));
	trace(fibonacci211(35));
	trace(fibonacci212(35));
	trace(fibonacci213(35));
	trace(fibonacci214(35));
	trace(fibonacci215(35));
	trace(fibonacci216(35));
	trace(fibonacci217(35));
	trace(fibonacci218(35));
	trace(fibonacci219(35));
	trace(fibonacci220(35));
	trace(fibonacci221(35));
	trace(fibonacci222(35));
	trace(fibonacci223(35));
	trace(fibonacci224(35));
	trace(fibonacci225(35));
	trace(fibonacci226(35));
	trace(fibonacci227(35));
	trace(fibonacci228(35));
	trace(fibonacci229(35));
	trace(fibonacci230(35));
	trace(fibonacci231(35));
	trace(fibonacci232(35));
	trace(fibonacci233(35));
	trace(fibonacci234(35));
	trace(fibonacci235(35));
	trace(fibonacci236(35));
	trace(fibonacci237(35));
	trace(fibonacci238(35));
	trace(fibonacci239(35));
	trace(fibonacci240(35));
	trace(fibonacci241(35));
	trace(fibonacci242(35));
	trace(fibonacci243(35));
	trace(fibonacci244(35));
	trace(fibonacci245(35));
	trace(fibonacci246(35));
	trace(fibonacci247(35));
	trace(fibonacci248(35));
	trace(fibonacci249(35));
	trace(fibonacci250(35));
	trace(fibonacci251(35));
	trace(fibonacci252(35));
	trace(fibonacci253(35));
	trace(fibonacci254(35));
	trace(fibonacci255(35));
	trace(fibonacci256(35));
	trace(fibonacci257(35));
	trace(fibonacci258(35));
	trace(fibonacci259(35));
	trace(fibonacci260(35));
	trace(fibonacci261(35));
	trace(fibonacci262(35));
	trace(fibonacci263(35));
	trace(fibonacci264(35));
	trace(fibonacci265(35));
	trace(fibonacci266(35));
	trace(fibonacci267(35));
	trace(fibonacci268(35));
	trace(fibonacci269(35));
	trace(fibonacci270(35));
	trace(fibonacci271(35));
	trace(fibonacci272(35));
	trace(fibonacci273(35));
	trace(fibonacci274(35));
	trace(fibonacci275(35));
	trace(fibonacci276(35));
	trace(fibonacci277(35));
	trace(fibonacci278(35));
	trace(fibonacci279(35));
	trace(fibonacci280(35));
	trace(fibonacci281(35));
	trace(fibonacci282(35));
	trace(fibonacci283(35));
	trace(fibonacci284(35));
	trace(fibonacci285(35));
	trace(fibonacci286(35));
	trace(fibonacci287(35));
	trace(fibonacci288(35));
	trace(fibonacci289(35));
	trace(fibonacci290(35));
	trace(fibonacci291(35));
	trace(fibonacci292(35));
	trace(fibonacci293(35));
	trace(fibonacci294(35));
	trace(fibonacci295(35));
	trace(fibonacci296(35));
	trace(fibonacci297(35));
	trace(fibonacci298(35));
	trace(fibonacci299(35));
	trace(fibonacci300(35));
	trace(fibonacci301(35));
	trace(fibonacci302(35));
	trace(fibonacci303(35));
	trace(fibonacci304(35));
	trace(fibonacci305(35));
	trace(fibonacci306(35));
	trace(fibonacci307(35));
	trace(fibonacci308(35));
	trace(fibonacci309(35));
	trace(fibonacci310(35));
	trace(fibonacci311(35));
	trace(fibonacci312(35));
	trace(fibonacci313(35));
	trace(fibonacci314(35));
	trace(fibonacci315(35));
	trace(fibonacci316(35));
	trace(fibonacci317(35));
	trace(fibonacci318(35));
	trace(fibonacci319(35));
	trace(fibonacci320(35));
	trace(fibonacci321(35));
	trace(fibonacci322(35));
	trace(fibonacci323(35));
	trace(fibonacci324(35));
	trace(fibonacci325(35));
	trace(fibonacci326(35));
	trace(fibonacci327(35));
	trace(fibonacci328(35));
	trace(fibonacci329(35));
	trace(fibonacci330(35));
	trace(fibonacci331(35));
	trace(fibonacci332(35));
	trace(fibonacci333(35));
	trace(fibonacci334(35));
	trace(fibonacci335(35));
	trace(fibonacci336(35));
	trace(fibonacci337(35));
	trace(fibonacci338(35));
	trace(fibonacci339(35));
	trace(fibonacci340(35));
	trace(fibonacci341(35));
	trace(fibonacci342(35));
	trace(fibonacci343(35));
	trace(fibonacci344(35));
	trace(fibonacci345(35));
	trace(fibonacci346(35));
	trace(fibonacci347(35));
	trace(fibonacci348(35));
	trace(fibonacci349(35));
	trace(fibonacci350(35));
	trace(fibonacci351(35));
	trace(fibonacci352(35));
	trace(fibonacci353(35));
	trace(fibonacci354(35));
	trace(fibonacci355(35));
	trace(fibonacci356(35));
	trace(fibonacci357(35));
	trace(fibonacci358(35));
	trace(fibonacci359(35));
	trace(fibonacci360(35));
	trace(fibonacci361(35));
	trace(fibonacci362(35));
	trace(fibonacci363(35));
	trace(fibonacci364(35));
	trace(fibonacci365(35));
	trace(fibonacci366(35));
	trace(fibonacci367(35));
	trace(fibonacci368(35));
	trace(fibonacci369(35));
	trace(fibonacci370(35));
	trace(fibonacci371(35));
	trace(fibonacci372(35));
	trace(fibonacci373(35));
	trace(fibonacci374(35));
	trace(fibonacci375(35));
	trace(fibonacci376(35));
	trace(fibonacci377(35));
	trace(fibonacci378(35));
	trace(fibonacci379(35));
	trace(fibonacci380(35));
	trace(fibonacci381(35));
	trace(fibonacci382(35));
	trace(fibonacci383(35));
	trace(fibonacci384(35));
	trace(fibonacci385(35));
	trace(fibonacci386(35));
	trace(fibonacci387(35));
	trace(fibonacci388(35));
	trace(fibonacci389(35));
	trace(fibonacci390(35));
	trace(fibonacci391(35));
	trace(fibonacci392(35));
	trace(fibonacci393(35));
	trace(fibonacci394(35));
	trace(fibonacci395(35));
	trace(fibonacci396(35));
	trace(fibonacci397(35));
	trace(fibonacci398(35));
	trace(fibonacci399(35));
	trace(fibonacci400(35));
	trace(fibonacci401(35));
	trace(fibonacci402(35));
	trace(fibonacci403(35));
	trace(fibonacci404(35));
	trace(fibonacci405(35));
	trace(fibonacci406(35));
	trace(fibonacci407(35));
	trace(fibonacci408(35));
	trace(fibonacci409(35));
	trace(fibonacci410(35));
	trace(fibonacci411(35));
	trace(fibonacci412(35));
	trace(fibonacci413(35));
	trace(fibonacci414(35));
	trace(fibonacci415(35));
	trace(fibonacci416(35));
	trace(fibonacci417(35));
	trace(fibonacci418(35));
	trace(fibonacci419(35));
	trace(fibonacci420(35));
	trace(fibonacci421(35));
	trace(fibonacci422(35));
	trace(fibonacci423(35));
	trace(fibonacci424(35));
	trace(fibonacci425(35));
	trace(fibonacci426(35));
	trace(fibonacci427(35));
	trace(fibonacci428(35));
	trace(fibonacci429(35));
	trace(fibonacci430(35));
	trace(fibonacci431(35));
	trace(fibonacci432(35));
	trace(fibonacci433(35));
	trace(fibonacci434(35));
	trace(fibonacci435(35));
	trace(fibonacci436(35));
	trace(fibonacci437(35));
	trace(fibonacci438(35));
	trace(fibonacci439(35));
	trace(fibonacci440(35));
	trace(fibonacci441(35));
	trace(fibonacci442(35));
	trace(fibonacci443(35));
	trace(fibonacci444(35));
	trace(fibonacci445(35));
	trace(fibonacci446(35));
	trace(fibonacci447(35));
	trace(fibonacci448(35));
	trace(fibonacci449(35));
	trace(fibonacci450(35));
	trace(fibonacci451(35));
	trace(fibonacci452(35));
	trace(fibonacci453(35));
	trace(fibonacci454(35));
	trace(fibonacci455(35));
	trace(fibonacci456(35));
	trace(fibonacci457(35));
	trace(fibonacci458(35));
	trace(fibonacci459(35));
	trace(fibonacci460(35));
	trace(fibonacci461(35));
	trace(fibonacci462(35));
	trace(fibonacci463(35));
	trace(fibonacci464(35));
	trace(fibonacci465(35));
	trace(fibonacci466(35));
	trace(fibonacci467(35));
	trace(fibonacci468(35));
	trace(fibonacci469(35));
	trace(fibonacci470(35));
	trace(fibonacci471(35));
	trace(fibonacci472(35));
	trace(fibonacci473(35));
	trace(fibonacci474(35));
	trace(fibonacci475(35));
	trace(fibonacci476(35));
	trace(fibonacci477(35));
	trace(fibonacci478(35));
	trace(fibonacci479(35));
	trace(fibonacci480(35));
	trace(fibonacci481(35));
	trace(fibonacci482(35));
	trace(fibonacci483(35));
	trace(fibonacci484(35));
	trace(fibonacci485(35));
	trace(fibonacci486(35));
	trace(fibonacci487(35));
	trace(fibonacci488(35));
	trace(fibonacci489(35));
	trace(fibonacci490(35));
	trace(fibonacci491(35));
	trace(fibonacci492(35));
	trace(fibonacci493(35));
	trace(fibonacci494(35));
	trace(fibonacci495(35));
	trace(fibonacci496(35));
	trace(fibonacci497(35));
	trace(fibonacci498(35));
	trace(fibonacci499(35));
	trace(fibonacci500(35));
	trace(fibonacci501(35));
	trace(fibonacci502(35));
	trace(fibonacci503(35));
	trace(fibonacci504(35));
	trace(fibonacci505(35));
	trace(fibonacci506(35));
	trace(fibonacci507(35));
	trace(fibonacci508(35));
	trace(fibonacci509(35));
	trace(fibonacci510(35));
	trace(fibonacci511(35));
	trace(fibonacci512(35));
	trace(factorial1(10));
	trace(factorial2(10));
	trace(factorial3(10));
	trace(factorial4(10));
	trace(factorial5(10));
	trace(factorial6(10));
	trace(factorial7(10));
	trace(factorial8(10));
	trace(factorial9(10));
	trace(factorial10(10));
	trace(factorial11(10));
	trace(factorial12(10));
	trace(factorial13(10));
	trace(factorial14(10));
	trace(factorial15(10));
	trace(factorial16(10));
	trace(factorial17(10));
	trace(factorial18(10));
	trace(factorial19(10));
	trace(factorial20(10));
	trace(factorial21(10));
	trace(factorial22(10));
	trace(factorial23(10));
	trace(factorial24(10));
	trace(factorial25(10));
	trace(factorial26(10));
	trace(factorial27(10));
	trace(factorial28(10));
	trace(factorial29(10));
	trace(factorial30(10));
	trace(factorial31(10));
	trace(factorial32(10));
	trace(factorial33(10));
	trace(factorial34(10));
	trace(factorial35(10));
	trace(factorial36(10));
	trace(factorial37(10));
	trace(factorial38(10));
	trace(factorial39(10));
	trace(factorial40(10));
	trace(factorial41(10));
	trace(factorial42(10));
	trace(factorial43(10));
	trace(factorial44(10));
	trace(factorial45(10));
	trace(factorial46(10));
	trace(factorial47(10));
	trace(factorial48(10));
	trace(factorial49(10));
	trace(factorial50(10));
	trace(factorial51(10));
	trace(factorial52(10));
	trace(factorial53(10));
	trace(factorial54(10));
	trace(factorial55(10));
	trace(factorial56(10));
	trace(factorial57(10));
	trace(factorial58(10));
	trace(factorial59(10));
	trace(factorial60(10));
	trace(factorial61(10));
	trace(factorial62(10));
	trace(factorial63(10));
	trace(factorial64(10));
	trace(factorial65(10));
	trace(factorial66(10));
	trace(factorial67(10));
	trace(factorial68(10));
	trace(factorial69(10));
	trace(factorial70(10));
	trace(factorial71(10));
	trace(factorial72(10));
	trace(factorial73(10));
	trace(factorial74(10));
	trace(factorial75(10));
	trace(factorial76(10));
	trace(factorial77(10));
	trace(factorial78(10));
	trace(factorial79(10));
	trace(factorial80(10));
	trace(factorial81(10));
	trace(factorial82(10));
	trace(factorial83(10));
	trace(factorial84(10));
	trace(factorial85(10));
	trace(factorial86(10));
	trace(factorial87(10));
	trace(factorial88(10));
	trace(factorial89(10));
	trace(factorial90(10));
	trace(factorial91(10));
	trace(factorial92(10));
	trace(factorial93(10));
	trace(factorial94(10));
	trace(factorial95(10));
	trace(factorial96(10));
	trace(factorial97(10));
	trace(factorial98(10));
	trace(factorial99(10));
	trace(factorial100(10));
	trace(factorial101(10));
	trace(factorial102(10));
	trace(factorial103(10));
	trace(factorial104(10));
	trace(factorial105(10));
	trace(factorial106(10));
	trace(factorial107(10));
	trace(factorial108(10));
	trace(factorial109(10));
	trace(factorial110(10));
	trace(factorial111(10));
	trace(factorial112(10));
	trace(factorial113(10));
	trace(factorial114(10));
	trace(factorial115(10));
	trace(factorial116(10));
	trace(factorial117(10));
	trace(factorial118(10));
	trace(factorial119(10));
	trace(factorial120(10));
	trace(factorial121(10));
	trace(factorial122(10));
	trace(factorial123(10));
	trace(factorial124(10));
	trace(factorial125(10));
	trace(factorial126(10));
	trace(factorial127(10));
	trace(factorial128(10));
	trace(factorial129(10));
	trace(factorial130(10));
	trace(factorial131(10));
	trace(factorial132(10));
	trace(factorial133(10));
	trace(factorial134(10));
	trace(factorial135(10));
	trace(factorial136(10));
	trace(factorial137(10));
	trace(factorial138(10));
	trace(factorial139(10));
	trace(factorial140(10));
	trace(factorial141(10));
	trace(factorial142(10));
	trace(factorial143(10));
	trace(factorial144(10));
	trace(factorial145(10));
	trace(factorial146(10));
	trace(factorial147(10));
	trace(factorial148(10));
	trace(factorial149(10));
	trace(factorial150(10));
	trace(factorial151(10));
	trace(factorial152(10));
	trace(factorial153(10));
	trace(factorial154(10));
	trace(factorial155(10));
	trace(factorial156(10));
	trace(factorial157(10));
	trace(factorial158(10));
	trace(factorial159(10));
	trace(factorial160(10));
	trace(factorial161(10));
	trace(factorial162(10));
	trace(factorial163(10));
	trace(factorial164(10));
	trace(factorial165(10));
	trace(factorial166(10));
	trace(factorial167(10));
	trace(factorial168(10));
	trace(factorial169(10));
	trace(factorial170(10));
	trace(factorial171(10));
	trace(factorial172(10));
	trace(factorial173(10));
	trace(factorial174(10));
	trace(factorial175(10));
	trace(factorial176(10));
	trace(factorial177(10));
	trace(factorial178(10));
	trace(factorial179(10));
	trace(factorial180(10));
	trace(factorial181(10));
	trace(factorial182(10));
	trace(factorial183(10));
	trace(factorial184(10));
	trace(factorial185(10));
	trace(factorial186(10));
	trace(factorial187(10));
	trace(factorial188(10));
	trace(factorial189(10));
	trace(factorial190(10));
	trace(factorial191(10));
	trace(factorial192(10));
	trace(factorial193(10));
	trace(factorial194(10));
	trace(factorial195(10));
	trace(factorial196(10));
	trace(factorial197(10));
	trace(factorial198(10));
	trace(factorial199(10));
	trace(factorial200(10));
	trace(factorial201(10));
	trace(factorial202(10));
	trace(factorial203(10));
	trace(factorial204(10));
	trace(factorial205(10));
	trace(factorial206(10));
	trace(factorial207(10));
	trace(factorial208(10));
	trace(factorial209(10));
	trace(factorial210(10));
	trace(factorial211(10));
	trace(factorial212(10));
	trace(factorial213(10));
	trace(factorial214(10));
	trace(factorial215(10));
	trace(factorial216(10));
	trace(factorial217(10));
	trace(factorial218(10));
	trace(factorial219(10));
	trace(factorial220(10));
	trace(factorial221(10));
	trace(factorial222(10));
	trace(factorial223(10));
	trace(factorial224(10));
	trace(factorial225(10));
	trace(factorial226(10));
	trace(factorial227(10));
	trace(factorial228(10));
	trace(factorial229(10));
	trace(factorial230(10));
	trace(factorial231(10));
	trace(factorial232(10));
	trace(factorial233(10));
	trace(factorial234(10));
	trace(factorial235(10));
	trace(factorial236(10));
	trace(factorial237(10));
	trace(factorial238(10));
	trace(factorial239(10));
	trace(factorial240(10));
	trace(factorial241(10));
	trace(factorial242(10));
	trace(factorial243(10));
	trace(factorial244(10));
	trace(factorial245(10));
	trace(factorial246(10));
	trace(factorial247(10));
	trace(factorial248(10));
	trace(factorial249(10));
	trace(factorial250(10));
	trace(factorial251(10));
	trace(factorial252(10));
	trace(factorial253(10));
	trace(factorial254(10));
	trace(factorial255(10));
	trace(factorial256(10));
	trace(factorial257(10));
	trace(factorial258(10));
	trace(factorial259(10));
	trace(factorial260(10));
	trace(factorial261(10));
	trace(factorial262(10));
	trace(factorial263(10));
	trace(factorial264(10));
	trace(factorial265(10));
	trace(factorial266(10));
	trace(factorial267(10));
	trace(factorial268(10));
	trace(factorial269(10));
	trace(factorial270(10));
	trace(factorial271(10));
	trace(factorial272(10));
	trace(factorial273(10));
	trace(factorial274(10));
	trace(factorial275(10));
	trace(factorial276(10));
	trace(factorial277(10));
	trace(factorial278(10));
	trace(factorial279(10));
	trace(factorial280(10));
	trace(factorial281(10));
	trace(factorial282(10));
	trace(factorial283(10));
	trace(factorial284(10));
	trace(factorial285(10));
	trace(factorial286(10));
	trace(factorial287(10));
	trace(factorial288(10));
	trace(factorial289(10));
	trace(factorial290(10));
	trace(factorial291(10));
	trace(factorial292(10));
	trace(factorial293(10));
	trace(factorial294(10));
	trace(factorial295(10));
	trace(factorial296(10));
	trace(factorial297(10));
	trace(factorial298(10));
	trace(factorial299(10));
	trace(factorial300(10));
	trace(factorial301(10));
	trace(factorial302(10));
	trace(factorial303(10));
	trace(factorial304(10));
	trace(factorial305(10));
	trace(factorial306(10));
	trace(factorial307(10));
	trace(factorial308(10));
	trace(factorial309(10));
	trace(factorial310(10));
	trace(factorial311(10));
	trace(factorial312(10));
	trace(factorial313(10));
	trace(factorial314(10));
	trace(factorial315(10));
	trace(factorial316(10));
	trace(factorial317(10));
	trace(factorial318(10));
	trace(factorial319(10));
	trace(factorial320(10));
	trace(factorial321(10));
	trace(factorial322(10));
	trace(factorial323(10));
	trace(factorial324(10));
	trace(factorial325(10));
	trace(factorial326(10));
	trace(factorial327(10));
	trace(factorial328(10));
	trace(factorial329(10));
	trace(factorial330(10));
	trace(factorial331(10));
	trace(factorial332(10));
	trace(factorial333(10));
	trace(factorial334(10));
	trace(factorial335(10));
	trace(factorial336(10));
	trace(factorial337(10));
	trace(factorial338(10));
	trace(factorial339(10));
	trace(factorial340(10));
	trace(factorial341(10));
	trace(factorial342(10));
	trace(factorial343(10));
	trace(factorial344(10));
	trace(factorial345(10));
	trace(factorial346(10));
	trace(factorial347(10));
	trace(factorial348(10));
	trace(factorial349(10));
	trace(factorial350(10));
	trace(factorial351(10));
	trace(factorial352(10));
	trace(factorial353(10));
	trace(factorial354(10));
	trace(factorial355(10));
	trace(factorial356(10));
	trace(factorial357(10));
	trace(factorial358(10));
	trace(factorial359(10));
	trace(factorial360(10));
	trace(factorial361(10));
	trace(factorial362(10));
	trace(factorial363(10));
	trace(factorial364(10));
	trace(factorial365(10));
	trace(factorial366(10));
	trace(factorial367(10));
	trace(factorial368(10));
	trace(factorial369(10));
	trace(factorial370(10));
	trace(factorial371(10));
	trace(factorial372(10));
	trace(factorial373(10));
	trace(factorial374(10));
	trace(factorial375(10));
	trace(factorial376(10));
	trace(factorial377(10));
	trace(factorial378(10));
	trace(factorial379(10));
	trace(factorial380(10));
	trace(factorial381(10));
	trace(factorial382(10));
	trace(factorial383(10));
	trace(factorial384(10));
	trace(factorial385(10));
	trace(factorial386(10));
	trace(factorial387(10));
	trace(factorial388(10));
	trace(factorial389(10));
	trace(factorial390(10));
	trace(factorial391(10));
	trace(factorial392(10));
	trace(factorial393(10));
	trace(factorial394(10));
	trace(factorial395(10));
	trace(factorial396(10));
	trace(factorial397(10));
	trace(factorial398(10));
	trace(factorial399(10));
	trace(factorial400(10));
	trace(factorial401(10));
	trace(factorial402(10));
	trace(factorial403(10));
	trace(factorial404(10));
	trace(factorial405(10));
	trace(factorial406(10));
	trace(factorial407(10));
	trace(factorial408(10));
	trace(factorial409(10));
	trace(factorial410(10));
	trace(factorial411(10));
	trace(factorial412(10));
	trace(factorial413(10));
	trace(factorial414(10));
	trace(factorial415(10));
	trace(factorial416(10));
	trace(factorial417(10));
	trace(factorial418(10));
	trace(factorial419(10));
	trace(factorial420(10));
	trace(factorial421(10));
	trace(factorial422(10));
	trace(factorial423(10));
	trace(factorial424(10));
	trace(factorial425(10));
	trace(factorial426(10));
	trace(factorial427(10));
	trace(factorial428(10));
	trace(factorial429(10));
	trace(factorial430(10));
	trace(factorial431(10));
	trace(factorial432(10));
	trace(factorial433(10));
	trace(factorial434(10));
	trace(factorial435(10));
	trace(factorial436(10));
	trace(factorial437(10));
	trace(factorial438(10));
	trace(factorial439(10));
	trace(factorial440(10));
	trace(factorial441(10));
	trace(factorial442(10));
	trace(factorial443(10));
	trace(factorial444(10));
	trace(factorial445(10));
	trace(factorial446(10));
	trace(factorial447(10));
	trace(factorial448(10));
	trace(factorial449(10));
	trace(factorial450(10));
	trace(factorial451(10));
	trace(factorial452(10));
	trace(factorial453(10));
	trace(factorial454(10));
	trace(factorial455(10));
	trace(factorial456(10));
	trace(factorial457(10));
	trace(factorial458(10));
	trace(factorial459(10));
	trace(factorial460(10));
	trace(factorial461(10));
	trace(factorial462(10));
	trace(factorial463(10));
	trace(factorial464(10));
	trace(factorial465(10));
	trace(factorial466(10));
	trace(factorial467(10));
	trace(factorial468(10));
	trace(factorial469(10));
	trace(factorial470(10));
	trace(factorial471(10));
	trace(factorial472(10));
	trace(factorial473(10));
	trace(factorial474(10));
	trace(factorial475(10));
	trace(factorial476(10));
	trace(factorial477(10));
	trace(factorial478(10));
	trace(factorial479(10));
	trace(factorial480(10));
	trace(factorial481(10));
	trace(factorial482(10));
	trace(factorial483(10));
	trace(factorial484(10));
	trace(factorial485(10));
	trace(factorial486(10));
	trace(factorial487(10));
	trace(factorial488(10));
	trace(factorial489(10));
	trace(factorial490(10));
	trace(factorial491(10));
	trace(factorial492(10));
	trace(factorial493(10));
	trace(factorial494(10));
	trace(factorial495(10));
	trace(factorial496(10));
	trace(factorial497(10));
	trace(factorial498(10));
	trace(factorial499(10));
	trace(factorial500(10));
	trace(factorial501(10));
	trace(factorial502(10));
	trace(factorial503(10));
	trace(factorial504(10));
	trace(factorial505(10));
	trace(factorial506(10));
	trace(factorial507(10));
	trace(factorial508(10));
	trace(factorial509(10));
	trace(factorial510(10));
	trace(factorial511(10));
	trace(factorial512(10));
}

fn fibonacci1(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci2(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci3(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci4(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci5(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci6(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci7(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci8(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci9(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci10(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci11(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci12(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci13(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci14(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci15(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci16(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci17(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci18(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci19(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci20(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci21(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci22(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci23(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci24(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci25(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci26(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci27(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci28(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci29(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci30(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci31(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci32(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci33(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci34(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci35(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci36(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci37(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci38(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci39(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci40(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci41(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci42(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci43(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci44(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci45(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci46(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci47(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci48(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci49(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci50(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci51(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci52(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci53(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci54(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci55(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci56(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci57(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci58(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci59(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci60(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci61(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci62(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci63(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci64(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci65(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci66(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci67(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci68(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci69(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci70(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci71(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci72(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci73(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci74(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci75(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci76(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci77(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci78(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci79(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci80(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci81(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci82(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci83(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci84(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci85(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci86(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci87(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci88(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci89(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci90(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci91(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci92(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci93(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci94(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci95(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci96(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci97(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci98(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci99(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci100(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci101(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci102(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci103(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci104(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci105(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci106(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci107(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci108(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci109(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci110(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci111(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci112(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci113(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci114(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci115(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci116(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci117(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci118(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci119(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci120(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci121(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci122(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci123(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci124(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci125(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci126(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci127(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci128(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci129(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci130(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci131(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci132(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci133(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci134(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci135(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci136(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci137(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci138(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci139(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci140(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci141(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci142(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci143(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci144(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci145(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci146(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci147(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci148(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci149(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci150(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci151(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci152(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci153(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci154(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci155(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci156(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci157(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci158(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci159(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci160(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci161(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci162(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci163(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci164(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci165(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci166(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci167(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci168(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci169(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci170(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci171(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci172(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci173(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci174(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci175(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci176(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci177(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci178(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci179(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci180(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci181(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci182(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci183(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci184(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci185(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci186(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci187(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci188(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci189(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci190(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci191(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci192(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci193(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci194(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci195(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci196(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci197(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci198(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci199(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci200(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci201(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci202(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci203(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci204(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci205(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci206(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci207(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci208(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci209(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci210(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci211(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci212(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci213(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci214(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci215(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci216(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci217(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci218(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci219(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci220(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci221(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci222(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci223(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci224(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci225(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci226(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci227(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci228(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci229(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci230(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci231(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci232(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci233(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci234(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci235(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci236(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci237(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci238(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci239(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci240(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci241(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci242(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci243(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci244(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci245(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci246(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci247(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci248(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci249(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci250(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci251(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci252(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci253(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci254(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci255(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci256(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci257(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci258(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci259(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci260(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci261(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci262(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci263(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci264(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci265(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci266(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci267(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci268(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci269(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci270(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci271(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci272(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci273(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci274(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci275(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci276(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci277(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci278(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci279(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci280(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci281(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci282(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci283(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci284(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci285(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci286(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci287(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci288(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci289(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci290(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci291(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci292(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci293(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci294(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci295(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci296(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci297(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci298(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci299(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci300(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci301(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci302(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci303(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci304(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci305(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci306(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci307(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci308(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci309(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci310(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci311(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci312(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci313(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci314(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci315(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci316(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci317(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci318(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci319(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci320(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci321(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci322(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci323(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci324(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci325(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci326(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci327(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci328(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci329(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci330(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci331(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci332(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci333(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci334(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci335(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci336(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci337(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci338(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci339(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci340(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci341(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci342(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci343(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci344(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci345(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci346(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci347(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci348(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci349(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci350(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci351(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci352(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci353(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci354(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci355(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci356(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci357(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci358(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci359(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci360(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci361(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci362(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci363(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci364(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci365(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci366(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci367(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci368(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci369(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci370(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci371(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci372(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci373(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci374(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci375(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci376(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci377(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci378(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci379(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci380(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci381(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci382(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci383(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci384(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci385(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci386(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci387(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci388(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci389(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci390(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci391(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci392(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci393(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci394(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci395(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci396(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci397(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci398(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci399(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci400(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci401(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci402(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci403(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci404(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci405(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci406(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci407(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci408(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci409(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci410(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci411(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci412(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci413(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci414(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci415(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci416(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci417(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci418(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci419(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci420(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci421(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci422(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci423(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci424(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci425(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci426(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci427(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci428(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci429(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci430(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci431(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci432(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci433(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci434(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci435(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci436(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci437(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci438(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci439(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci440(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci441(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci442(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci443(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci444(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci445(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci446(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci447(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci448(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci449(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci450(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci451(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci452(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci453(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci454(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci455(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci456(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci457(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci458(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci459(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci460(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci461(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci462(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci463(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci464(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci465(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci466(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci467(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci468(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci469(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci470(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci471(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci472(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci473(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci474(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci475(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci476(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci477(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci478(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci479(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci480(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci481(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci482(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci483(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci484(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci485(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci486(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci487(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci488(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci489(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci490(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci491(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci492(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci493(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci494(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci495(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci496(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci497(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci498(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci499(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci500(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci501(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci502(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci503(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci504(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci505(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci506(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci507(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci508(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci509(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci510(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci511(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}
fn fibonacci512(n: u64) -> u64 {
	let ~first = 1;
	let ~second = 1;

	let ~counter = 1;
	loop counter == 1 => counter == n {
		let summation = first + second;
		first <=> second;
		second <=> summation;

		// `summation` contains the original `first`
		drop summation = second - first;
		counter += 1;
	}

	// Implicit drop of `first` and `counter`
	drop n = counter;
	second
}

fn factorial1(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial2(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial3(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial4(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial5(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial6(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial7(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial8(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial9(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial10(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial11(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial12(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial13(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial14(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial15(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial16(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial17(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial18(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial19(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial20(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial21(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial22(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial23(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial24(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial25(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial26(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial27(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial28(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial29(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial30(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial31(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial32(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial33(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial34(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial35(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial36(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial37(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial38(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial39(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial40(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial41(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial42(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial43(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial44(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial45(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial46(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial47(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial48(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial49(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial50(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial51(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial52(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial53(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial54(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial55(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial56(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial57(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial58(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial59(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial60(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial61(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial62(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial63(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial64(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial65(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial66(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial67(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial68(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial69(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial70(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial71(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial72(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial73(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial74(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial75(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial76(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial77(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial78(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial79(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial80(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial81(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial82(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial83(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial84(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial85(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial86(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial87(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial88(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial89(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial90(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial91(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial92(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial93(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial94(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial95(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial96(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial97(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial98(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial99(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial100(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial101(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial102(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial103(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial104(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial105(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial106(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial107(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial108(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial109(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial110(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial111(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial112(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial113(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial114(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial115(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial116(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial117(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial118(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial119(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial120(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial121(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial122(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial123(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial124(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial125(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial126(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial127(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial128(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial129(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial130(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial131(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial132(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial133(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial134(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial135(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial136(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial137(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial138(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial139(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial140(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial141(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial142(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial143(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial144(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial145(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial146(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial147(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial148(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial149(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial150(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial151(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial152(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial153(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial154(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial155(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial156(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial157(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial158(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial159(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial160(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial161(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial162(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial163(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial164(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial165(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial166(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial167(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial168(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial169(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial170(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial171(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial172(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial173(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial174(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial175(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial176(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial177(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial178(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial179(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial180(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial181(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial182(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial183(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial184(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial185(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial186(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial187(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial188(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial189(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial190(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial191(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial192(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial193(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial194(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial195(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial196(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial197(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial198(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial199(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial200(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial201(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial202(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial203(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial204(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial205(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial206(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial207(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial208(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial209(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial210(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial211(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial212(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial213(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial214(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial215(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial216(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial217(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial218(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial219(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial220(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial221(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial222(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial223(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial224(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial225(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial226(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial227(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial228(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial229(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial230(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial231(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial232(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial233(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial234(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial235(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial236(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial237(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial238(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial239(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial240(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial241(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial242(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial243(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial244(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial245(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial246(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial247(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial248(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial249(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial250(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial251(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial252(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial253(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial254(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial255(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial256(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial257(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial258(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial259(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial260(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial261(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial262(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial263(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial264(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial265(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial266(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial267(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial268(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial269(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial270(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial271(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial272(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial273(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial274(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial275(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial276(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial277(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial278(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial279(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial280(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial281(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial282(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial283(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial284(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial285(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial286(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial287(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial288(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial289(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial290(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial291(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial292(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial293(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial294(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial295(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial296(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial297(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial298(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial299(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial300(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial301(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial302(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial303(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial304(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial305(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial306(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial307(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial308(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial309(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial310(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial311(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial312(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial313(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial314(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial315(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial316(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial317(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial318(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial319(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial320(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial321(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial322(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial323(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial324(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial325(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial326(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial327(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial328(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial329(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial330(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial331(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial332(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial333(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial334(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial335(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial336(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial337(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial338(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial339(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial340(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial341(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial342(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial343(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial344(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial345(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial346(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial347(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial348(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial349(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial350(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial351(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial352(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial353(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial354(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial355(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial356(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial357(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial358(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial359(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial360(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial361(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial362(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial363(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial364(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial365(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial366(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial367(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial368(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial369(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial370(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial371(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial372(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial373(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial374(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial375(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial376(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial377(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial378(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial379(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial380(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial381(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial382(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial383(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial384(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial385(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial386(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial387(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial388(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial389(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial390(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial391(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial392(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial393(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial394(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial395(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial396(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial397(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial398(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial399(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial400(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial401(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial402(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial403(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial404(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial405(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial406(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial407(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial408(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial409(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial410(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial411(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial412(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial413(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial414(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial415(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial416(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial417(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial418(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial419(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial420(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial421(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial422(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial423(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial424(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial425(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial426(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial427(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial428(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial429(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial430(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial431(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial432(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial433(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial434(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial435(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial436(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial437(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial438(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial439(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial440(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial441(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial442(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial443(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial444(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial445(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial446(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial447(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial448(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial449(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial450(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial451(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial452(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial453(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial454(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial455(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial456(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial457(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial458(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial459(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial460(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial461(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial462(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial463(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial464(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial465(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial466(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial467(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial468(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial469(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial470(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial471(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial472(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial473(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial474(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial475(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial476(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial477(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial478(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial479(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial480(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial481(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial482(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial483(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial484(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial485(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial486(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial487(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial488(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial489(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial490(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial491(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial492(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial493(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial494(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial495(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial496(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial497(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial498(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial499(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial500(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial501(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial502(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial503(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial504(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial505(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial506(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial507(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial508(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial509(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial510(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial511(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
fn factorial512(n: u64) -> u64 {
	let ~result = 1;
	let ~counter = 1;
	loop counter == 1 => counter == n + 1 {
		result *= counter;
		counter += 1;
	}

	// Implicit drop of `n`
	drop counter = n + 1;
	result
}
