fn function(immutable: u64, ~mutable: u64) -> u64 {
	let ~addition = immutable + mutable;
	let ~subtraction = immutable - mutable;
	let multiplication = immutable * mutable;
//	let division = immutable / mutable;

	let ~counter = 0;
	loop counter == 0 => counter == immutable {
		counter += 1;
	}

	drop counter = immutable;
	when immutable == 0 => immutable == 0 {
		mutable -= addition;
		mutable *= subtraction;
//		mutable /= multiplication;
	}

	when {
		immutable == 1 => immutable == 1 -> addition += 1,
		immutable == 2 => immutable == 2 -> subtraction += 1,
		immutable == 3 => immutable == 3 -> addition -= 1,
		true => true -> subtraction -= 1,
	}

	immutable
}

fn return_position_conditional(variable: u64) -> u64 {
	let expression_block: u64 = {
		let first = 0;
		let second = 1;
		first + second
	};

	when {
		variable == 0 => variable == 0 -> 0,
		variable == 1 => variable == 1 -> 1,
		variable == 2 => variable == 2 -> 2,
	}
}

fn nested_shadow() {
	let variable: u64 = 0;
	when true => true {
		let variable: u32 = 0;
		let other: u32 = 1;
		variable += other;
	}

	let other: u64 = 1;
	variable += other;
}

fn nested_drop() {
	let variable: u64 = 3;
	drop variable = {
		let variable = 2;
		let addition = variable + 1;

		nested_shadow();
		addition
	};
}

fn main() {
	trace(function(5, 3));
	trace(return_position_conditional(1));
	nested_drop();
}
